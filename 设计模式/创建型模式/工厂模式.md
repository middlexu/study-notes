# 工厂模式

工厂模式的作用：

对象的创建和使用的过程分开

具体可参考https://blog.csdn.net/lovelion/article/details/7523392



## 简单工厂

（1）创建Shape接口

```java
public interface Shape {
    void draw();
}
```
（2）创建实现该接口的具体图形类

圆形
```java
public class Circle implements Shape {
    public Circle() {
        System.out.println("Circle");
    }
    @Override
    public void draw() {
        System.out.println("Draw Circle");
    }
}
```

长方形
```java
public class Rectangle implements Shape {
    public Rectangle() {
        System.out.println("Rectangle");
    }
    @Override
    public void draw() {
        System.out.println("Draw Rectangle");
    }
}
```

正方形
```java
public class Square implements Shape {
    public Square() {
        System.out.println("Square");
    }

    @Override
    public void draw() {
        System.out.println("Draw Square");
    }
}
```

（3）创建工厂类：

```java
public class ShapeFactory {

    // 使用 getShape 方法获取形状类型的对象
    public static Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        } else if (shapeType.equalsIgnoreCase("SQUARE")) {
            return new Square();
        }
        return null;
    }
}
```

（4）测试方法：
```java
public class Test {

    public static void main(String[] args) {
    
        // 获取 Circle 的对象，并调用它的 draw 方法
        Shape circle = ShapeFactory.getShape("CIRCLE");
        circle.draw();
    
        // 获取 Rectangle 的对象，并调用它的 draw 方法
        Shape rectangle = ShapeFactory.getShape("RECTANGLE");
        rectangle.draw();
    
        // 获取 Square 的对象，并调用它的 draw 方法
        Shape square = ShapeFactory.getShape("SQUARE");
        square.draw();
    }
}
```
输出结果：
```
Circle
Draw Circle
Rectangle
Draw Rectangle
Square
Draw Square
```
这样的实现有个问题，如果我们新增产品类的话，就需要修改工厂类中的getShape()方法，这很明显不符合 开放-封闭原则 。



**使用反射机制改善简单工厂**

将工厂类改为下面的形式：

```java
package factory_pattern;

/**
 * 利用反射解决简单工厂每次增加新了产品类都要修改产品工厂的弊端
 * 
 * @author Administrator
 *
 */
public class ShapeFactory2 {
    public static Object getClass(Class<? extends Shape> clazz) {
        Object obj = null;

        try {
            obj = Class.forName(clazz.getName()).newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        
        return obj;
    }
}
```

测试方法：
```java
package factory_pattern;

public class Test2 {
    public static void main(String[] args) {

        Circle circle = (Circle) ShapeFactory2.getClass(factory_pattern.Circle.class);
        circle.draw();
    
        Rectangle rectangle = (Rectangle) ShapeFactory2.getClass(factory_pattern.Rectangle.class);
        rectangle.draw();
    
        Square square = (Square) ShapeFactory2.getClass(factory_pattern.Square.class);
        square.draw();
    }

}
```

这种方式的虽然符合了 开放-关闭原则 ，但是每一次传入的都是产品类的全部路径，这样比较麻烦。如果需要改善的话可以通过 反射+配置文件 的形式来改善，这种方式使用的也是比较多的。





## 工厂方法

（1）**增加一个工厂接口**：
```java
public interface Factory {
    public Shape getShape();
}
```

（2）增加相关工厂类:

圆形工厂类
```java
public class CircleFactory implements Factory {

    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Circle();
    }

}
```
长方形工厂类
```java
public class RectangleFactory implements Factory{

    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Rectangle();
    }

}
```
圆形工厂类
```java
public class SquareFactory implements Factory{

    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Square();
    }

}
```
（3）测试：
```java
public class Test {

    public static void main(String[] args) {
        Factory circlefactory = new CircleFactory();
        Shape circle = circlefactory.getShape();
        circle.draw();
    }

}
```
输出结果：
```
Circle
Draw Circle
```





## 抽象工厂

（1）创建相关接口：

枪
```java
public interface Gun {
    public void shooting();
}
```

子弹
```java
public interface Bullet {
    public void load();
}
```
（2）创建接口对应实现类：

AK类
```java
public class AK implements Gun{

    @Override
    public void shooting() {
        System.out.println("shooting with AK");
    
    }

}
```

M4A1类
```java
public class M4A1 implements Gun {

    @Override
    public void shooting() {
        System.out.println("shooting with M4A1");
    
    }

}
```

AK子弹类
```java
public class AK_Bullet implements Bullet {

    @Override
    public void load() {
        System.out.println("Load bullets with AK");
    }

}
```

M4A1子弹类
```java
public class M4A1
_Bullet implements Bullet {

    @Override
    public void load() {
        System.out.println("Load bullets with M4A1");
    }

}
```

（3）创建工厂接口
```java
public interface Factory {
    public Gun produceGun();
    public Bullet produceBullet();
}
```

（4）创建具体工厂

生产AK和AK子弹的工厂
```java
public class AK_Factory implements Factory{

    @Override
    public Gun produceGun() {
        return new AK();
    }
    
    @Override
    public Bullet produceBullet() {
        return new AK_Bullet();
    }

}
```

生产M4A1和M4A1子弹的工厂
```java
public class M4A1_Factory implements Factory{

    @Override
    public Gun produceGun() {
        return new M4A1();
    }
    
    @Override
    public Bullet produceBullet() {
        return new M4A1_Bullet();
    }

}
```

（5）测试
```java
public class Test {

    public static void main(String[] args) {  
    
     Factory factory;
     Gun gun;
     Bullet bullet;
    
     factory =new AK_Factory();
     bullet=factory.produceBullet();
     bullet.load();
     gun=factory.produceGun();
     gun.shooting(); 
    
    }

}
```

输出结果：
```
Load bullets with AK
shooting with AK
```





## 总结

简单工厂：

一个统一的工厂类来创建所有的对象



工厂方法：

针对不同的对象提供不同的工厂，每个对象都有一个与之对应的工厂 



抽象方法：

生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的

