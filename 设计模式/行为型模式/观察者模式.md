# 观察者模式

建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。

观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式



在观察者设计模式中，一般有四个角色：

- 抽象主题角色（Subject）
- 具体主题角色（ConcreteSubject）
- 抽象观察者角色（Observer）
- 具体观察者角色（ConcreteObserver）



## 案例

此类不属于观察者模式必须的类，用来存放事件的信息。

```java
public class News {
    private String title;
    private String content;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}

```



抽象主题角色，在这个角色中，有一个字段peopleList，用来保存【观察者】的引用，同时定义了两个接口，这是Java8默认接口实现的写法。这两个接口是给客户端调用的，用来【删除观察者】【增加观察者】，还提供一个方法，此方法需要被【具体主题角色】重写，用来通知各个【观察者】。

```java
public interface Subject {
    List<People> peopleList = new ArrayList<>();

    default void add(People people) {
        peopleList.add(people);
    }

    default void remove(People people) {
        peopleList.remove(people);
    }

    void update();
}

```



具体主题角色，重写了【抽象主题角色】的方法，循环列表，通知各个【观察者】。

```java
public class NewsSubject implements Subject{
    public void update() {
        for (People people : peopleList) {
            News news = new News();
            news.setContent("今日在大街上，有人躲在草丛中袭击路人，还大喊“德玛西亚万岁”");
            news.setTitle("德玛西亚出现了");
            people.update(news);
        }
    }
}

```



抽象观察者角色，定义了一个接口，【具体观察者角色】需要重写这个方法。

```java
public interface People { //函数式接口
    void update(News news);
}

```



下面就是【具体观察者角色】了：

```java
public class PeopleA implements People {
    @Override
    public void update(News news) {
        System.out.println("这个新闻真好看");
    }
}
```
```java
public class PeopleB implements People {
    @Override
    public void update(News news) {
        System.out.println("这个新闻真无语");
    }
}
```
```java
public class PeopleC implements People {
    @Override
    public void update(News news) {
        System.out.println("这个新闻真逗");
    }
}

```



客户端：

```java
public class Main {
    public static void main(String[] args) {
        Subject subject = new NewsSubject();
        subject.add(new PeopleA());
        subject.add(new PeopleB());
        subject.add(new PeopleC());
        subject.update();
    }
}
```

结果

```
这个新闻真好看
这个新闻真无语
这个新闻真逗
```



客户端

```java
public static void main(String[] args) {
        Subject subject = new NewsSubject();
        subject.add(a -> System.out.println("已阅这新闻"));// 函数式接口
        subject.add(a -> System.out.println("假的吧"));
        subject.add(a -> System.out.println("昨天就看过了"));
        subject.update();
}
```

结果

```
已阅这新闻
假的吧
昨天就看过了
```



## 优缺点

**观察者模式的优点**

- 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。
- 观察者模式在观察目标和观察者之间建立一个抽象的耦合。
- 观察者模式支持广播通信。
- 观察者模式符合“开闭原则”的要求。



**观察者模式的缺点**

- 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。



## 适用环境

在以下情况下可以使用观察者模式：

- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
- 一个对象必须通知其他对象，而并不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。



## 模式应用

观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。