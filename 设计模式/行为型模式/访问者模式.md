# 访问者模式

1) 访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前 提下定义作用于这些元素的新的操作。

2) 主要将数据结构与数据操作分离，解决 数据结构和操作耦合性问题 

3) 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口

4) 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作"污染"这些对象的类，可以选用访问者模式解决





## 案例

我们将创建一个定义接受操作的 *ComputerPart* 接口。*Keyboard*、*Mouse*、*Monitor* 和 *Computer* 是实现了 *ComputerPart* 接口的实体类。我们将定义另一个接口 *ComputerPartVisitor*，它定义了访问者类的操作

（实体类，操作类）



步骤 1
定义一个表示元素的接口。
```java
//ComputerPart.java
public interface ComputerPart { //稳定的数据结构
   public void accept(ComputerPartVisitor computerPartVisitor);
}
```

步骤 2
创建扩展了上述类的实体类。
```java
//Keyboard.java
public class Keyboard  implements ComputerPart {
 
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}
```
```java
//Monitor.java
public class Monitor  implements ComputerPart {
 
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}
```
```java
//Mouse.java
public class Mouse  implements ComputerPart {
 
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}
```
```java
//Computer.java
public class Computer implements ComputerPart {
   
   ComputerPart[] parts;
 
   public Computer(){
      parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()};      
   } 
 
 
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      for (int i = 0; i < parts.length; i++) {
         parts[i].accept(computerPartVisitor);
      }
      computerPartVisitor.visit(this);
   }
}
```

步骤 3
定义一个表示访问者的接口。

```java
//ComputerPartVisitor.java
public interface ComputerPartVisitor { //易变的方法
   public void visit(Computer computer);
   public void visit(Mouse mouse);
   public void visit(Keyboard keyboard);
   public void visit(Monitor monitor);
}
```

步骤 4
创建实现了上述类的实体访问者。

```java
//ComputerPartDisplayVisitor.java
public class ComputerPartDisplayVisitor implements ComputerPartVisitor {
 
   @Override
   public void visit(Computer computer) {
      System.out.println("Displaying Computer.");
   }
 
   @Override
   public void visit(Mouse mouse) {
      System.out.println("Displaying Mouse.");
   }
 
   @Override
   public void visit(Keyboard keyboard) {
      System.out.println("Displaying Keyboard.");
   }
 
   @Override
   public void visit(Monitor monitor) {
      System.out.println("Displaying Monitor.");
   }
}
```

步骤 5
使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分。
```java
//VisitorPatternDemo.java
public class VisitorPatternDemo {
   public static void main(String[] args) {
 
      ComputerPart computer = new Computer();
      computer.accept(new ComputerPartDisplayVisitor());
   }
}
```

步骤 6
执行程序，输出结果：
```
Displaying Mouse.
Displaying Keyboard.
Displaying Monitor.
Displaying Computer.
```



在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。



## 访问者模式的注意事项和细节

优点

 1) 访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高 

2) 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统 



缺点 

1) 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的, 这样造 成了具体元素变更比较困难

2) 违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素 

3) 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的.



