# 解释器模式





## 示例
```java
//解释器接口
public interface Expression {
    int interpreter(Context context);//一定会有解释方法
}
```

```java
//抽象非终结符表达式
public abstract class NonTerminalExpression implements Expression{
    Expression e1,e2;
    public NonTerminalExpression(Expression e1, Expression e2){

        this.e1 = e1;
        this.e2 = e2;
    }
}
```

```java
//加法表达式实现类
public class PlusOperation extends NonTerminalExpression {

    public PlusOperation(Expression e1, Expression e2) {
        super(e1, e2);
    }

    //将两个表达式相加
    @Override
    public int interpreter(Context context) {
        return this.e1.interpreter(context) + this.e2.interpreter(context);
    }
}
```

```java
//减法表达式实现类
public class MinusOperation extends NonTerminalExpression {

    public MinusOperation(Expression e1, Expression e2) {
        super(e1, e2);
    }

   //将两个表达式相减
    @Override
    public int interpreter(Context context) {
        return this.e1.interpreter(context) - this.e2.interpreter(context);
    }
}
```

```java
//终结符表达式（在这个例子，用来存放数字，或者代表数字的字符）
public class TerminalExpression implements Expression{

    String variable;
    public TerminalExpression(String variable){

        this.variable = variable;
    }
    @Override
    public int interpreter(Context context) {
        return context.lookup(this);
    }
}
```



```java
// 环境类。包含解释器之外的一些全局信息，一般是 HashMap
public class Context {
    private Map<Expression, Integer> map = new HashMap<>();

    public void add(Expression s, Integer value){
        map.put(s, value);
    }
    public Integer lookup(Expression s){
        return map.get(s);
    }
    //构建语法树的主要方法
    public static Expression build(String str) {
        //主要利用栈来实现
        Stack<Expression> objects = new Stack<>();
        for (int i = 0; i < str.length(); i++){
            char c = str.charAt(i);
            //遇到运算符号+号时候
            if (c == '+'){

                //先出栈
                Expression pop = objects.pop();

                //将运算结果入栈
                objects.push(new PlusOperation(pop, new TerminalExpression(String.valueOf(str.charAt(++i)))));
            } else if (c == '-'){
                //遇到减号类似加号
                Expression pop = objects.pop();

                objects.push(new MinusOperation(pop, new TerminalExpression(String.valueOf(str.charAt(++i)))));

            } else {
                //遇到非终结符直接入栈（基本就是第一个数字的情况）
                objects.push(new TerminalExpression(String.valueOf(str.charAt(i))));
            }
        }
        //把最后的栈顶元素返回
        return objects.pop();
    }
}
```

```java
//终结符实现类
public class TerminalExpression implements Expression {

    String variable;
    public TerminalExpression(String variable){

        this.variable = variable;
    }
    @Override
    public int interpreter(Context context) {
        //因为要兼容之前的版本
        Integer lookup = context.lookup(this);
        if (lookup == null)
            //若在map中能找到对应的数则返回
            return Integer.valueOf(variable);
        //找不到则直接返回（认为输入的就是数字）
        return lookup;
    }
}
```

```java
public class Test {
   public static void main(String[] args) {
	 Context context = new Context();
     String str = "4+8-2+9+9-8";
     Expression build = Context.build(str);
     System.out.println("4+8-2+9+9-8=" + build.interpreter(context));


     
     TerminalExpression a = new TerminalExpression("a");
     TerminalExpression b = new TerminalExpression("b");
     TerminalExpression c = new TerminalExpression("c");
     context.add(a, 4);
     context.add(b, 8);
     context.add(c, 2);

     System.out.println(new MinusOperation(new PlusOperation(a,b), c).interpreter(context));
     System.out.println(Context.build("a+b-c").interpreter(context));
   }
}

运行结果如下
-----------------------------------------
4+8-2+9+9-8=20
10
10
```



参考https://blog.csdn.net/niunai112/article/details/79982712





## 相关性质

**应用实例：**编译器、运算表达式计算。

**优点：** 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。

**缺点：** 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。

**使用场景：** 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。

**注意事项：**可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。对数学表达式计算可参考http://www.findsrc.com/java/detail/8664