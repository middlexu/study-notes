# 桥接模式

桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。



## 示例

对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:

![桥接模式案例.jpg](https://i.loli.net/2019/07/08/5d22a07084e5f45120.jpg)





传统模式会有扩展性问题(类爆炸)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加 一个手机品牌，也要在各个手机样式类下增加。



```java
public interface Brand { 
    void open(); 
    void close(); 
    void call();
}
```



```java
public class Vivo implements Brand {
    @Override

    public void open() { 
        // TODOAuto-generated method stub 
        System.out.println(" Vivo 手机开机 ");
    }

    @Override
    public void close() { 
        // TODOAuto-generated method stub 
        System.out.println(" Vivo 手机关机 ");
    }

    @Override
    public void call() { 
        // TODOAuto-generated method stub 
        System.out.println(" Vivo 手机打电话 ");
    }
}
```



```java
public class XiaoMi implements Brand {
    @Override
    public void open() {
        // TODOAuto-generated method stub
        System.out.println(" 小米手机开机 ");
    }

    @Override
    public void close() {
        // TODOAuto-generated method stub 
        System.out.println(" 小米手机关机 ");
    }

    @Override
    public void call() {
        // TODOAuto-generated method stub 
        System.out.println(" 小米手机打电话 ");
    }
}
```



```java
public abstract class Phone {
    //组合品牌 ,这里提现了桥
    private Brand brand;
	//构造器 
    public Phone(Brand brand) { 
        super(); 
        this.brand = brand;
	}
    
protected void open() { 
    this.brand.open();
} 
protected void close() { 
    brand.close();
} 
protected void call() { 
    brand.call();
}
```



```java
public class FoldedPhone extends Phone {//折叠式
    //构造器 
    public FoldedPhone(Brand brand) {
        super(brand);
    }

    public void open() {
        super.open();
        System.out.println(" 折叠样式手机 ");
    }

    public void close() {
        super.close();
        System.out.println(" 折叠样式手机 ");
    }

    public void call() {
        super.call();
        System.out.println(" 折叠样式手机 ");
    }
}
```



```java
public class UpRightPhone extends Phone {//直立式
    //构造器 
    public UpRightPhone(Brand brand) {
        super(brand);
    }

    public void open() {
        super.open();
        System.out.println(" 直立样式手机 ");
    }

    public void close() {
        super.close();
        System.out.println(" 直立样式手机 ");
    }

    public void call() {
        super.call();
        System.out.println(" 直立样式手机 ");
    }
}
```



```java
public class Client {
    public static void main(String[] args) {
        //获取折叠式手机 (样式 + 品牌 )
        Phone phone1 = new FoldedPhone(new XiaoMi());
        phone1.open();
        phone1.call();
        phone1.close();
        System.out.println("=======================");
        Phone phone2 = new FoldedPhone(new Vivo());
        phone2.open();
        phone2.call();
        phone2.close();
        System.out.println("==============");
        UpRightPhone phone3 = new UpRightPhone(new XiaoMi());
        phone3.open();
        phone3.call();
        phone3.close();
        System.out.println("==============");
        UpRightPhone phone4 = new UpRightPhone(new Vivo());
        phone4.open();
        phone4.call();
        phone4.close();
    }
}
```





## 桥接模式的注意事项和细节

1) 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于 系统进行分层设计，从而产生更好的结构化系统。

2) 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。 

3) 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。

4) 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设 计和编程

5) 桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需 要有这样的应用场景。





## 常见的应用场景

1) -JDBC 驱动程序 

2) -银行转账系统 转账分类: 网上转账，柜台转账，AMT 转账 转账用户类型：普通用户，银卡用户，金卡用户.. 

3) -消息管理 

消息类型：即时消息，延时消息
消息分类：手机短信，邮件消息，QQ消息...