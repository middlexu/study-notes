# 代理模式

代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。现实世界的代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，似乎当事人并不存在，因为他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。

在软件设计中，使用代理模式的意图也很多，比如因为安全原因需要屏蔽客户端直接访问真实对象，或者在远程调用中需要使用代理类处理远程方法调用的技术细节 (如 RMI)，也可能为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。

代理模式角色分为 4 种：

1. 主题接口：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；
2. 真实主题：真正实现业务逻辑的类；
3. 代理类：用来代理和封装真实主题；
4. Main：客户端，使用代理类和主题接口完成一些工作。





## 静态代理

延迟加载的核心思想是：如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的原有的位置，只要在真正需要的时候才对它进行加载。使用代理模式的延迟加载是非常有意义的，首先，它可以在时间轴上分散系统压力，尤其在系统启动时，不必完成所有的初始化工作，从而加速启动时间；其次，对很多真实主题而言，在软件启动直到被关闭的整个过程中，可能根本不会被调用，初始化这些数据无疑是一种资源浪费。例如使用代理类封装数据库查询类后，系统的启动过程这个例子。若系统不使用代理模式，则在启动时就要初始化 DBQuery 对象，而使用代理模式后，启动时只需要初始化一个轻量级的对象 DBQueryProxy。

下面代码 IDBQuery 是主题接口，定义代理类和真实类需要对外提供的服务，定义了实现数据库查询的公共方法 request() 函数。DBQuery 是真实主题，负责实际的业务操作，DBQueryProxy 是 DBQuery 的代理类。

```java
public interface IDBQuery {
    String request();
}


public class DBQuery implements IDBQuery{
    public DBQuery(){
        try{
            Thread.sleep(1000);//假设数据库连接等耗时操作
        }catch(InterruptedException ex){
            ex.printStackTrace();
        }
    }

    @Override
    public String request() {
        // TODO Auto-generated method stub
        return "request string";
    }
    
}


public class DBQueryProxy implements IDBQuery{
    private DBQuery real = null;

    @Override
    public String request() {
        // TODO Auto-generated method stub
        //在真正需要的时候才能创建真实对象，创建过程可能很慢
        if(real==null){
            real = new DBQuery();
        }//在多线程环境下，这里返回一个虚假类，类似于 Future 模式
        return real.request();
    }

}


public class Main {
    public static void main(String[] args){
        IDBQuery q = new DBQueryProxy(); //使用代里
        q.request(); //在真正使用时才创建真实对象
    }
}

```





## 动态代理



### JDK动态代理

接口：

```java
package com.lanhuigu.spring.proxy.compare;

/**
 * 用户管理接口(真实主题和代理主题的共同接口，这样在任何可以使用真实主题的地方都可以使用代理主题代理。)
 * --被代理接口定义
 */
public interface IUserManager {
    void addUser(String id, String password);
}
```

实现类：

```java
package com.lanhuigu.spring.proxy.compare;

/**
 * 用户管理接口实现(被代理的实现类)
 */
public class UserManagerImpl implements IUserManager {

    @Override
    public void addUser(String id, String password) {
        System.out.println("======调用了UserManagerImpl.addUser()方法======");
    }
}
```

JDK代理实现：

```java
package com.lanhuigu.spring.proxy.compare;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * JDK动态代理类
 */
public class JDKProxy implements InvocationHandler {
    /** 需要代理的目标对象 */
    private Object targetObject;

    /**
     * 将目标对象传入进行代理
     */
    public Object newProxy(Object targetObject) {
        this.targetObject = targetObject;
        //返回代理对象
        return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),
                targetObject.getClass().getInterfaces(), this);
    }

    /**
     * invoke方法
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 一般我们进行逻辑处理的函数比如这个地方是模拟检查权限
        checkPopedom();
        // 设置方法的返回值
        Object ret = null;
        // 调用invoke方法，ret存储该方法的返回值
        ret  = method.invoke(targetObject, args);
        return ret;
    }

    /**
     * 模拟检查权限的例子
     */
    private void checkPopedom() {
        System.out.println("======检查权限checkPopedom()======");
    }
}
```





### CGLIB动态代理

需要额外的jar包

```java
package com.lanhuigu.spring.proxy.compare;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * CGLibProxy动态代理类
 */
public class CGLibProxy implements MethodInterceptor {
    /** CGLib需要代理的目标对象 */
    private Object targetObject;

    public Object createProxyObject(Object obj) {
        this.targetObject = obj;
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(obj.getClass());
        enhancer.setCallback(this);
        Object proxyObj = enhancer.create();
        // 返回obj的代理对象
        return proxyObj;
    }

    @Override
    public Object intercept(Object proxy, Method method, Object[] args,
                            MethodProxy methodProxy) throws Throwable {
        Object obj = null;
        // 过滤方法
        if ("addUser".equals(method.getName())) {
            // 检查权限
            checkPopedom();
        }
        obj = method.invoke(targetObject, args);
        return obj;
    }

    private void checkPopedom() {
        System.out.println("======检查权限checkPopedom()======");
    }
}
```

客户端测试类：
```java
package com.lanhuigu.spring.proxy.compare;

/**
 * 代理模式[[ 客户端--》代理对象--》目标对象 ]]
 */
public class Client {  
  
    public static void main(String[] args) {  
  
        UserManager userManager = (UserManager) new CGLibProxy()  
                .createProxyObject(new UserManagerImpl());  
        System.out.println("-----------CGLibProxy-------------");  
        userManager.addUser("tom", "root");  
        System.out.println("-----------JDKProxy-------------");  
        JDKProxy jdkPrpxy = new JDKProxy();  
        UserManager userManagerJDK = (UserManager) jdkPrpxy  
                .newProxy(new UserManagerImpl());  
        userManagerJDK.addUser("tom", "root");  
    }  
  
} 

```

运行结果

```
-----------CGLibProxy-------------  
检查权限  checkPopedom()!  
掉用了UserManagerImpl.addUser()方法！   
-----------JDKProxy-------------  
检查权限  checkPopedom()!  
掉用了UserManagerImpl.addUser()方法！

```





### JDK动态代理语法

放轻松，下面我们开始讲解语法，语法非常简单。

动态代码涉及了一个非常重要的类 Proxy。正是通过 Proxy 的静态方法 newProxyInstance 才会动态创建代理。



#### Proxy

```java
public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
```

下面讲解它的 3 个参数意义。

- loader 自然是类加载器

- interfaces 代码要用来代理的接口

- h 一个 InvocationHandler 对象



#### InvocationHandler

InvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。

```java
public interface InvocationHandler {

    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```

InvocationHandler 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。

- proxy 代理对象

- method 代理对象调用的方法

- args 调用的方法中的参数


因为，Proxy 动态产生的代理会调用 InvocationHandler 实现类，所以 InvocationHandler 是实际执行者。







## JDK动态代理和CGLIB字节码生成的区别？

 （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类

 （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法
   因为是继承，所以该类或方法最好不要声明成final 





## 代理的作用

可能有同学会问，已经学习了代理的知识，但是，它们有什么用呢？

主要作用，还是在不修改被代理对象的源码上，进行功能的增强。

这在 AOP 面向切面编程领域经常见。

> 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。



> 主要功能
> 日志记录，性能统计，安全控制，事务处理，异常处理等等。








## 代理模式的应用场合

代理模式有多种应用场合，如下所述：

1. 远程代理，也就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实。比如说 WebService，当我们在应用程序的项目中加入一个 Web 引用，引用一个 WebService，此时会在项目中声称一个 WebReference 的文件夹和一些文件，这个就是起代理作用的，这样可以让那个客户端程序调用代理解决远程访问的问题；
2. 虚拟代理，是根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象。这样就可以达到性能的最优化，比如打开一个网页，这个网页里面包含了大量的文字和图片，但我们可以很快看到文字，但是图片却是一张一张地下载后才能看到，那些未打开的图片框，就是通过虚拟代里来替换了真实的图片，此时代理存储了真实图片的路径和尺寸；
3. 安全代理，用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候；
4. 指针引用，是指当调用真实的对象时，代理处理另外一些事。比如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它，或当第一次引用一个持久对象时，将它装入内存，或是在访问一个实际对象前，检查是否已经释放它，以确保其他对象不能改变它。这些都是通过代理在访问一个对象时附加一些内务处理；
5. 延迟加载，用代理模式实现延迟加载的一个经典应用就在 Hibernate 框架里面。当 Hibernate 加载实体 bean 时，并不会一次性将数据库所有的数据都装载。默认情况下，它会采取延迟加载的机制，以提高系统的性能。Hibernate 中的延迟加载主要分为属性的延迟加载和关联表的延时加载两类。实现原理是使用代理拦截原有的 getter 方法，在真正使用对象数据时才去数据库或者其他第三方组件加载实际的数据，从而提升系统性能。